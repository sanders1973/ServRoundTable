<!doctype html>
<html lang="en-au">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Round Table</title>
  <meta name="description" content="Capture team mood & updates." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='46' fill='%234b6bfb'/%3E%3Ctext x='50' y='58' font-size='46' text-anchor='middle' fill='white' font-family='Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif'%3ERT%3C/text%3E%3C/svg%3E" />
  <style>
    /* THEME TOKENS */
    body { margin:0; font: 14px/1.5 Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

    /* Dark = fully black */
    body[data-theme="dark"]{
      --bg: #000000;
      --panel: #000000;
      --panel-2: #000000;
      --ink: #e6ebff;
      --ink-dim: #c4cdfb;
      --ink-muted: #9aa7ee;
      --brand: #4b6bfb;
      --brand-2: #6a8bff;
      --ok: #2ecc71;
      --border: rgba(255,255,255,.10);
      --border-2: rgba(255,255,255,.06);
      --shadow: 0 10px 30px rgba(0,0,0,.45);
      --pill-bg: rgba(255,255,255,.06);
      --pill-border: rgba(255,255,255,.08);
      --danger: #ff4d4f;
    }
    /* Light theme */
    body[data-theme="light"]{
      --bg: #f7f9fc;
      --panel: #ffffff;
      --panel-2: #ffffff;
      --ink: #0b1020;
      --ink-dim: #1f2937;
      --ink-muted: #6b7280;
      --brand: #3658ff;
      --brand-2: #5e7bff;
      --ok: #1f9d56;
      --border: rgba(0,0,0,.12);
      --border-2: rgba(0,0,0,.06);
      --shadow: 0 10px 30px rgba(0,0,0,.08);
      --pill-bg: rgba(0,0,0,.04);
      --pill-border: rgba(0,0,0,.08);
      --danger: #d92d2f;
    }

    html, body { height: 100%; }
    body { background: var(--bg); color: var(--ink); }

    header { position: sticky; top: 0; z-index: 10; backdrop-filter: saturate(120%) blur(6px); background: color-mix(in oklab, var(--bg) 92%, transparent); border-bottom: 1px solid var(--border-2); }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 20px; }
    .bar { display:flex; align-items:center; gap:14px; flex-wrap:wrap; }
    .logo { width:40px; height:40px; display:grid; place-items:center; background: linear-gradient(140deg, var(--brand), var(--brand-2)); color:#fff; border-radius: 12px; font-weight: 800; letter-spacing:.5px; box-shadow: var(--shadow); }
    .title { font-size: 22px; font-weight: 800; margin:0; letter-spacing:.2px; }
    .title small { display:block; font-size: 12px; color: var(--ink-muted); font-weight: 600; }
    .spacer { flex: 1; }
    .pill { display:inline-flex; align-items:center; gap:10px; padding:8px 12px; border-radius: 999px; background: var(--pill-bg); color: var(--ink); border: 1px solid var(--pill-border); }

    /* Mode toggle segmented control */
    .mode-toggle { padding: 4px; gap: 4px; }
    .seg { appearance:none; border:none; padding:8px 10px; border-radius: 8px; font-weight:800; cursor:pointer; color: var(--ink); background: transparent; }
    .seg.active { background: color-mix(in oklab, var(--brand) 18%, transparent); border:1px solid color-mix(in oklab, var(--brand) 40%, transparent); }

    main { padding: 28px 0 40px; }

    /* Two equal columns */
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 22px; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }

    .card { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid var(--border-2); border-radius: 22px; box-shadow: var(--shadow); overflow: hidden; }
    .card h2 { margin:0 0 14px; font-size:18px; letter-spacing:.2px; }
    .card .pad { padding: 18px; }

    /* Form layout */
    .row { display:grid; grid-template-columns: 150px 1fr; gap: 14px; align-items:center; margin: 12px 0; }
    .row > :nth-child(2) { min-width: 0; }
    @media (max-width: 640px){ .row { grid-template-columns: 1fr; } }

    label { color: var(--ink-dim); font-weight: 600; }
    input[type="text"], textarea, input[type="number"], input[type="range"], select, input[type="date"], input[type="password"] { box-sizing: border-box; max-width: 100%; }
    input[type="text"], textarea, input[type="number"], input[type="date"], input[type="password"] { width: 100%; color: var(--ink); background: color-mix(in oklab, var(--panel) 88%, white 0%); border: 1px solid var(--border); border-radius: 12px; padding: 10px 12px; outline: none; transition: border .2s, box-shadow .2s; }
    input[type="text"]:focus, textarea:focus, input[type="number"]:focus, input[type="date"]:focus, input[type="password"]:focus { border-color: var(--brand-2); box-shadow: 0 0 0 3px color-mix(in oklab, var(--brand) 25%, transparent); }
    textarea { min-height: 120px; resize: vertical; }

    .range { display:grid; grid-template-columns: 1fr auto; gap: 10px; align-items:center; }
    input[type="range"]{ width:100%; }
    .bubble { min-width: 42px; text-align:center; padding:6px 10px; border-radius: 10px; background: var(--pill-bg); border: 1px solid var(--pill-border); font-weight:700; }

    .chip-row { display:flex; gap:8px; flex-wrap:wrap; }
    .chip { padding:6px 10px; border-radius: 999px; border:1px solid var(--border); background: var(--pill-bg); cursor:pointer; user-select:none; }
    .chip.active { outline:2px solid var(--brand); background: color-mix(in oklab, var(--brand) 18%, transparent); }

    .btn { appearance:none; border:none; cursor:pointer; font-weight: 800; letter-spacing:.3px; padding: 12px 16px; border-radius: 14px; color:#fff; background: linear-gradient(140deg, var(--brand), var(--brand-2)); box-shadow: var(--shadow); transition: transform .04s ease-in-out, filter .2s; }
    .btn:hover { filter: brightness(1.06); }
    .btn:active{ transform: translateY(1px); }
    .btn.secondary { background: var(--pill-bg); border: 1px solid var(--border); color: var(--ink); }
    .btn.danger { background: var(--danger); color: #fff; }

    .muted { color: var(--ink-muted); }

    .stats { display:flex; flex-wrap:wrap; gap:10px; }
    .stat { display:grid; gap:4px; padding:10px 12px; border-radius:12px; background: var(--pill-bg); border:1px solid var(--border); min-width: 150px; }

    .toolbar { display:flex; flex-wrap:wrap; gap:18px; align-items:flex-start; justify-content: space-between; margin: 0 0 12px; }
    .toolbar .left { display:flex; gap:10px; align-items:center; }

    .controls-stack { display:grid; gap:8px; min-width: 260px; }
    .control-row { display:flex; align-items:center; gap:8px; }
    .control-row label { width: 70px; color: var(--ink-muted); }
    .control-row input, .control-row select { flex:1; }

    /* Gauges */
    .gauge-row { display:flex; gap:14px; flex-wrap:wrap; margin: 14px 0 24px; }
    .gauge-semi { width: 180px; position: relative; }
    .gauge-semi svg { width: 100%; height: auto; display: block; }
    .gauge-semi .center { position:absolute; left:50%; top:66%; transform:translateX(-50%); text-align:center; }
    .gauge-semi .value { font-size: 22px; font-weight: 800; }
    .gauge-semi .label { font-size: 12px; color: var(--ink-muted); margin-top: 2px; }
    .arc-track { fill:none; stroke: var(--border); stroke-width: 14; stroke-linecap: round; }
    .arc-value { fill:none; stroke: var(--brand); stroke-width: 14; stroke-linecap: round; transition: stroke-dasharray .3s ease; }
    .needle { stroke: var(--brand-2); stroke-width: 2.5; transform-origin: 100px 110px; transition: transform .35s ease; }
    .hub { fill: rgba(255,255,255,.9); }

    /* Single-column list of teammate updates */
    .updates-grid { display:grid; grid-template-columns: 1fr; gap: 14px; }
    .update-card { padding: 14px; border-radius: 14px; background: color-mix(in oklab, var(--panel) 94%, white 0%); border: 1px solid var(--border); }
    .update-head { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:6px; }
    .who { font-weight:800; letter-spacing:.3px; display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .when { color: var(--ink-muted); font-size:12px; }

    /* Badge chips for speaking state */
    .tag { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; border:1px solid var(--pill-border); background: var(--pill-bg); font-size:11px; font-weight:700; }
    .tag.live { border-color: color-mix(in oklab, var(--brand-2) 40%, transparent); background: color-mix(in oklab, var(--brand-2) 18%, transparent); }
    .tag.spoken { opacity:.85; }

    .reactions { display:flex; gap:8px; margin-top:10px; }
    .react-btn { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid var(--pill-border); background: var(--pill-bg); cursor:pointer; font-weight:800; color: var(--ink); }
    .react-btn .cnt { font-variant-numeric: tabular-nums; min-width: 1ch; text-align:right; color: var(--ink); }
    .react-btn.active { outline:2px solid var(--brand-2); }

    .export-bar { display:flex; gap:10px; justify-content:flex-end; margin-top: 16px; }

    /* Timers */
    .timer-block { padding: 12px; border-radius: 16px; border: 1px solid var(--border); background: color-mix(in oklab, var(--panel) 94%, white 0%); margin-bottom: 14px; }
    .timer-header { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 6px; }
    .timer-header h3 { margin:0; font-size: 16px; }
    .timer-controls { display:flex; align-items:center; gap:8px; }
    .timer-controls input { width: 120px; text-align:center; }
    .timer-display { font-variant-numeric: tabular-nums; font-feature-settings: 'tnum' 1; font-size: 44px; font-weight: 800; letter-spacing: 1px; text-align:center; padding: 8px 0; border-radius: 12px; }
    .timer-buttons { display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }

    /* Flash red when overtime */
    .overtime { color: var(--danger) !important; animation: pulseRed .8s ease-in-out infinite; }
    @keyframes pulseRed { 0% { box-shadow: 0 0 0 0 rgba(255,77,79,0.0); background: transparent; }
                          50% { box-shadow: 0 0 0 6px rgba(255,77,79,0.18); background: rgba(255,77,79,0.10); }
                         100% { box-shadow: 0 0 0 0 rgba(255,77,79,0.0); background: transparent; }
    }

    /* Collapsibles */
    details { border:1px solid var(--border); border-radius: 14px; padding: 10px 12px; background: color-mix(in oklab, var(--panel) 94%, white 0%); }
    details + details { margin-top: 12px; }
    details summary { cursor: pointer; user-select:none; font-weight: 800; color: var(--ink-dim); }
  </style>
</head>
<body data-theme="dark">
  <header>
    <div class="wrap bar">
      <div class="logo" aria-hidden="true">RT</div>
      <h1 class="title">Round Table <small id="teamNameDisplay">Team</small></h1>
      <div class="spacer"></div>

      <!-- Multi-team switcher populated from GitHub only -->
      <div class="pill" title="Switch team context">
        <label for="teamSwitcher" class="muted" style="margin-right:6px;">Team</label>
        <select id="teamSwitcher"></select>
      </div>

      <!-- Passphrase (next to team picker) -->
      <div class="pill" title="Enter passphrase for selected team">
        <label for="teamPassInput" class="muted">Passphrase</label>
        <input id="teamPassInput" class="pass-input" type="password" placeholder="Enter pass‚Ä¶" style="width: 150px;" />
        <span id="passMsg" class="muted" aria-live="polite"></span>
      </div>

      <!-- Mode toggle -->
      <div class="pill mode-toggle" role="group" aria-label="Mode">
        <button id="modeUserBtn" class="seg active" type="button">User</button>
        <button id="modeFacBtn" class="seg" type="button">Facilitator</button>
      </div>

      <!-- Theme toggle -->
      <button id="themeToggle" class="pill theme-toggle" type="button" aria-pressed="false" title="Toggle light/dark theme">
        <span id="themeIcon" aria-hidden="true">üåô</span>
        <span id="themeName">Dark</span>
      </button>

      <div class="pill" title="Live sync status">
        <svg width="10" height="10" viewBox="0 0 10 10" aria-hidden="true"><circle id="liveDot" cx="5" cy="5" r="5" fill="#8e9bd6"/></svg>
        <span id="liveLabel" class="muted">Idle</span>
      </div>
      <div class="pill" title="Live since last reload">
        <span class="muted">Live since</span>
        <span id="liveSinceTicker">0s</span>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap grid">
      <!-- LEFT COLUMN: User / Facilitator sections -->

      <!-- User section -->
      <section id="userSection" class="card" aria-labelledby="myUpdateHeading">
        <div class="pad">
          <h2 id="myUpdateHeading">Your update</h2>

          <form id="updateForm" novalidate>
            <div class="row">
              <label for="nameInput">Your name</label>
              <input id="nameInput" name="name" type="text" placeholder="e.g. Alex Taylor" autocomplete="name" required />
            </div>

            <div class="row">
              <label for="sessionInput">Session</label>
              <input id="sessionInput" name="session" type="date" />
            </div>

            <div class="row">
              <label for="feelingInput">How are you feeling?</label>
              <div>
                <div class="range">
                  <input id="feelingInput" name="feeling" type="range" min="1" max="10" step="1" value="5" />
                  <div class="bubble" id="feelingBubble" aria-live="polite">5</div>
                </div>
                <div class="chip-row" aria-label="Mood quick select">
                  <span class="chip" data-feel="2">üòû 2</span>
                  <span class="chip" data-feel="4">üòê 4</span>
                  <span class="chip" data-feel="6">üôÇ 6</span>
                  <span class="chip" data-feel="8">üòÑ 8</span>
                  <span class="chip" data-feel="10">ü§© 10</span>
                </div>
              </div>
            </div>

            <div class="row">
              <label for="productivityInput">How productive do you feel?</label>
              <div class="range">
                <input id="productivityInput" name="productivity" type="range" min="1" max="10" step="1" value="5" />
                <div class="bubble" id="productivityBubble" aria-live="polite">5</div>
              </div>
            </div>

            <div class="row">
              <label for="updateInput">Topics / notes</label>
              <textarea id="updateInput" name="update" placeholder="What would you like to share with the team? What's behind your scores?" maxlength="5000"></textarea>
            </div>

            <div class="row" style="align-items:flex-start;">
              <div></div>
              <div>
                <button id="submitBtn" type="submit" class="btn">Save my update</button>
                <button id="clearBtn" type="button" class="btn secondary">Clear</button>
                <div id="saveStatus" class="statusline" role="status" aria-live="polite"></div>
              </div>
            </div>
          </form>

          <hr class="divider" />
          <h3 class="muted" style="margin:10px 0 6px;">My last submission</h3>
          <div class="update-card" id="myLastCard">No submission yet.</div>
        </div>
      </section>

      <!-- Facilitator section -->
      <section id="facilitatorSection" class="card" aria-labelledby="facHeading" hidden>
        <div class="pad">
          <h2 id="facHeading">Facilitator</h2>

          <!-- Meeting total countdown (default 45 minutes) -->
          <div class="timer-block" aria-label="Meeting countdown">
            <div class="timer-header">
              <h3>Meeting timer</h3>
              <div class="timer-controls">
                <label class="muted" for="meetingMinutesInput">Minutes</label>
                <input id="meetingMinutesInput" type="number" min="1" max="600" value="45" />
              </div>
            </div>
            <div class="timer-display" id="meetingDisplay">45:00</div>
            <div class="timer-buttons">
              <button id="meetingStart" class="btn" type="button">Start</button>
              <button id="meetingStop" class="btn secondary" type="button">Stop</button>
              <button id="meetingReset" class="btn secondary" type="button">Reset</button>
            </div>
          </div>

          <!-- Speaker stopwatch / countdown (dynamic default minutes) -->
          <div class="timer-block" aria-label="Speaker timer">
            <div class="timer-header">
              <h3>Speaker timer</h3>
              <div class="timer-controls">
                <label class="muted" for="speakerMinutesInput">Minutes</label>
                <input id="speakerMinutesInput" type="number" min="0.1" max="60" step="0.1" value="2" />
              </div>
            </div>
            <div class="timer-display" id="speakerDisplay">02:00</div>
            <div class="timer-buttons">
              <button id="speakerStart" class="btn" type="button">Start</button>
              <button id="speakerStop" class="btn secondary" type="button">Stop</button>
              <button id="speakerClear" class="btn secondary" type="button">Clear</button>
            </div>
          </div>

          <!-- Speaker ordering controls -->
          <div class="timer-block" aria-label="Speaker order controls">
            <div class="timer-header">
              <h3>Speaker order</h3>
              <div class="muted" id="speakerCounts">Remaining: 0 ‚Ä¢ Spoken: 0</div>
            </div>
            <div class="timer-buttons">
              <button id="nextSpeakerBtn" class="btn" type="button">Next Speaker</button>
              <button id="speakerFinishedBtn" class="btn secondary" type="button">Speaker Finished</button>
              <button id="clearSpokenBtn" class="btn secondary" type="button">Clear All</button>
            </div>
          </div>

          <!-- Admin tools at the bottom: collapsibles -->
          <details id="adminCreateDetails">
            <summary>Create team</summary>
            <div class="timer-controls" style="gap:10px; flex-wrap:wrap; margin-top:10px;">
              <input id="newTeamInput" type="text" placeholder="e.g. Growth Squad" style="min-width:220px;" />
              <input id="newTeamPassInput" type="password" placeholder="Passphrase (optional)" style="min-width:220px;" />
              <button id="addTeamBtn" class="btn" type="button">Add</button>
              <span class="muted">Writes the team to the GitHub registry so everyone sees it.</span>
            </div>
          </details>

          <details id="adminDeleteDetails">
            <summary>Bulk delete (danger)</summary>
            <div style="display:grid; gap:12px; margin-top:10px;">
              <div class="timer-block" style="margin:0;">
                <div class="timer-header">
                  <h3>Delete a session (current team)</h3>
                  <span class="muted">Removes all files for the selected <b>session</b> in the current team.</span>
                </div>
                <div class="timer-controls" style="gap:10px; flex-wrap:wrap;">
                  <label class="muted" for="delSessionSelect">Session</label>
                  <select id="delSessionSelect"></select>
                  <button id="deleteSessionBtn" class="btn danger" type="button" title="Delete all files for this session">Delete session</button>
                </div>
              </div>

              <div class="timer-block" style="margin:0;">
                <div class="timer-header">
                  <h3>Delete a team</h3>
                  <span class="muted">Removes <b>all files</b> for the selected team (all sessions).</span>
                </div>
                <div class="timer-controls" style="gap:10px; flex-wrap:wrap;">
                  <label class="muted" for="delTeamSelect">Team</label>
                  <select id="delTeamSelect"></select>
                  <button id="deleteTeamBtn" class="btn danger" type="button" title="Delete all files for this team">Delete team</button>
                </div>
              </div>
            </div>
          </details>
        </div>
      </section>

      <!-- RIGHT COLUMN: Team Snapshot -->
      <aside class="card" aria-labelledby="summaryHeading">
        <div class="pad">
          <h2 id="summaryHeading">Team snapshot</h2>

          <div class="stats" style="margin-bottom:12px; display:none;">
            <div class="stat"><span class="muted">Average feeling</span><b id="avgFeeling">‚Äî</b></div>
            <div class="stat"><span class="muted">Average productivity</span><b id="avgProductivity">‚Äî</b></div>
          </div>
          <div class="stats" style="margin-bottom:12px;">
            <div class="stat"><span class="muted">Updates</span><b id="updatesCount">0</b></div>
          </div>

          <!-- Semi-arc Gauges with needle (blue/green) -->
          <div class="gauge-row">
            <div class="gauge-semi" id="gaugeFeeling" role="img" aria-label="Average feeling" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0">
              <svg viewBox="0 0 200 120" aria-hidden="true">
                <defs>
                  <linearGradient id="gradFeeling" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" stop-color="#4b6bfb"/>
                    <stop offset="100%" stop-color="#2ecc71"/>
                  </linearGradient>
                </defs>
                <path class="arc-track" d="M10,110 A90,90 0 0 1 190,110"/>
                <path class="arc-value" id="gaugeFeelingArc" d="M10,110 A90,90 0 0 1 190,110" stroke="url(#gradFeeling)" pathLength="100" stroke-dasharray="0 100"/>
                <line class="needle" id="gaugeFeelingNeedle" x1="100" y1="110" x2="100" y2="28" transform="rotate(-90 100 110)"/>
                <circle class="hub" cx="100" cy="110" r="4"/>
              </svg>
              <div class="center">
                <div class="value" id="gaugeFeelingVal">‚Äî</div>
                <div class="label">Feeling</div>
              </div>
            </div>
            <div class="gauge-semi" id="gaugeProductivity" role="img" aria-label="Average productivity" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0">
              <svg viewBox="0 0 200 120" aria-hidden="true">
                <defs>
                  <linearGradient id="gradProd" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" stop-color="#4b6bfb"/>
                    <stop offset="100%" stop-color="#2ecc71"/>
                  </linearGradient>
                </defs>
                <path class="arc-track" d="M10,110 A90,90 0 0 1 190,110"/>
                <path class="arc-value" id="gaugeProductivityArc" d="M10,110 A90,90 0 0 1 190,110" stroke="url(#gradProd)" pathLength="100" stroke-dasharray="0 100"/>
                <line class="needle" id="gaugeProductivityNeedle" x1="100" y1="110" x2="100" y2="28" transform="rotate(-90 100 110)"/>
                <circle class="hub" cx="100" cy="110" r="4"/>
              </svg>
              <div class="center">
                <div class="value" id="gaugeProductivityVal">‚Äî</div>
                <div class="label">Productivity</div>
              </div>
            </div>
          </div>

          <div class="toolbar">
            <div class="left">
              <button id="manualRefreshBtn" class="btn secondary" type="button">Refresh now</button>
              <span class="muted">Last refresh: <span id="lastRefresh">never</span></span>
            </div>
            <div class="controls-stack">
              <div class="control-row">
                <label class="muted" for="sessionFilter">Session</label>
                <input id="sessionFilter" type="date" />
              </div>
              <div class="control-row">
                <label class="muted" for="filterInput">Filter</label>
                <input id="filterInput" type="text" placeholder="Find by name or text‚Ä¶" />
              </div>
              <div class="control-row">
                <label class="muted" for="sortBySelect">Sort</label>
                <select id="sortBySelect">
                  <option value="updated_desc">Newest</option>
                  <option value="updated_asc">Oldest</option>
                  <option value="name_asc">Name A‚ÜíZ</option>
                  <option value="name_desc">Name Z‚ÜíA</option>
                  <option value="feeling_desc">Feeling High‚ÜíLow</option>
                  <option value="feeling_asc">Feeling Low‚ÜíHigh</option>
                  <option value="prod_desc">Productivity High‚ÜíLow</option>
                  <option value="prod_asc">Productivity Low‚ÜíHigh</option>
                </select>
              </div>
              <div class="control-row">
                <label class="muted">Status</label>
                <div class="pill mode-toggle" id="spokenSeg" role="group" aria-label="Spoken filter">
                  <button class="seg spk active" data-sfilter="all" id="spkAllBtn" type="button">All</button>
                  <button class="seg spk" data-sfilter="ready" id="spkReadyBtn" type="button">Not yet spoken</button>
                  <button class="seg spk" data-sfilter="spoken" id="spkSpokenBtn" type="button">Spoken</button>
                </div>
              </div>
            </div>
          </div>

          <div class="updates-grid" id="updatesGrid" aria-live="polite" aria-busy="false">
            <!-- teammate update cards render here (single column) -->
          </div>

          <div class="export-bar">
            <button id="exportCsvBtn" class="btn secondary" type="button" title="Export CSV of current session">Export CSV</button>
            <button id="exportJsonBtn" class="btn secondary" type="button" title="Export JSON of current session">Export JSON</button>
            <a id="downloadAnchor" style="display:none;"></a>
          </div>

          <details class="settings" style="margin-top:14px;">
            <summary>Diagnostics</summary>
            <div class="settings-body">
              <div class="settings-grid">
                <div>
                  <b>Token scope</b>
                  <div id="diagTokenScope" class="muted">‚Äî</div>
                </div>
                <div>
                  <b>Branch & directory</b>
                  <div id="diagBranchDir" class="muted">‚Äî</div>
                </div>
              </div>
              <div style="display:flex; gap:10px; align-items:center; margin-top:8px;">
                <button id="runDiagnosticsBtn" class="btn secondary" type="button">Run diagnostics</button>
                <span id="diagStatus" class="statusline">Idle</span>
              </div>
              <div style="margin-top:8px;">
                <b>Last API error</b>
                <div id="lastApiError" class="update-card" style="background:color-mix(in oklab, var(--brand-2) 15%, transparent); border-color: color-mix(in oklab, var(--brand-2) 40%, transparent);">None</div>
              </div>
            </div>
          </details>
        </div>
      </aside>
    </div>
  </main>

  <footer>
    <div class="wrap">Built for quick Round Table check‚Äëins.</div>
  </footer>

<script>
        
/**
 * Round Table ‚Äî Client-side app logic
 *
 * Major capabilities:
 * - Team registry in GitHub (`<DIR>/_teams/<TEAM>.json`) with optional passphrase
 * - GH-only Team picker (on load, populated from GitHub, not localStorage)
 * - Passphrase gating with per-team cached passphrases in localStorage
 * - Meeting sessions (TEAM -- NAME -- SESSION.txt), CSV/JSON export
 * - Reactions persisted within each user's own file (REACTIONS_B64), aggregated live
 * - Facilitator tools: timers, speaker order, counters
 * - Admin tools: create team (collapsible) and **bulk delete** by session or by team
 * - Smarter polling: ETag conditional + exponential backoff on 403/429
 * - Semi-arc gauges with needle (blue‚Üígreen), filters, sort, diagnostics
 */

// ======= OWNER-EDITABLE CONFIG (defaults) =======
const CONFIG_DEFAULTS = {
  TEAM_NAME: "GNT SLT",
  OWNER: "sanders1973",
  REPO: "RoundTable",
  BRANCH: "main",
  DIR: "roundtable",
  POLL_INTERVAL_MS: 10000,
  // ‚ö†Ô∏è Fine-grained token with Contents: Read & Write on target repo
  GITHUB_TOKEN: "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"
};

// ======= RUNTIME STATE =======
let state = {
  nextPollTimeout: null,
  isSyncing: false,
  backoffMs: 0,
  lastApiError: null,
  liveSinceMs: Date.now(),
  cache: { dir: {}, files: {} },
  currentUpdates: [],
  reactionTotals: new Map(),
  myReactions: { updated_at: null, by_target: {} },
  sfilter: 'all',
  speaker: null,
  _rxDebounceTimer: null,
  teamRegistry: new Map(), // team => { team, passphrase, created_at, created_by }
  teamLocked: false,
  teamsFromGh: [],
};

// LocalStorage keys
const LS_KEYS = {
  TEAM_NAME: "RT_teamName",
  POLL_INTERVAL_MS: "RT_pollInterval",
  OWNER: "RT_owner",
  REPO: "RT_repo",
  BRANCH: "RT_branch",
  DIR: "RT_dir",
  NAME: "RT_myName",
  SESSION: "RT_session",
  THEME: "RT_theme",
  MODE: "RT_mode", // 'user' | 'facilitator'
  SPOKEN_FILTER: "RT_spokenFilter",
};
const LS_PASS_PREFIX = 'RT_teamPass::'; // + team name
const LS_SPEAKER_PREFIX = 'RT_speaker_'; // + sessionKey

// ======= UTILITIES =======
const $ = (sel) => document.querySelector(sel);
const nowIso = () => new Date().toISOString();
const fmtLocal = (iso) => { const d = new Date(iso); return isNaN(d) ? "" : d.toLocaleString(); };
const pad = (n)=> (n<10?"0":"")+n;
const todayYmd = ()=> { const d=new Date(); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`; };
const toBase64 = (s)=> btoa(unescape(encodeURIComponent(String(s))));
const fromBase64 = (b)=> { try { return decodeURIComponent(escape(atob(b))); } catch { return ""; } };
function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#039;'); }
function linkify(t){ return String(t).replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener">$1<\/a>'); }

function getConfig(){
  const cfg = { ...CONFIG_DEFAULTS };
  const pick = (k)=>{ const v = localStorage.getItem(k); return v !== null && v !== undefined && v !== "" ? v : undefined; };
  cfg.TEAM_NAME = pick(LS_KEYS.TEAM_NAME) ?? cfg.TEAM_NAME;
  cfg.POLL_INTERVAL_MS = Number(pick(LS_KEYS.POLL_INTERVAL_MS) ?? cfg.POLL_INTERVAL_MS);
  cfg.OWNER = pick(LS_KEYS.OWNER) ?? cfg.OWNER;
  cfg.REPO = pick(LS_KEYS.REPO) ?? cfg.REPO;
  cfg.BRANCH = pick(LS_KEYS.BRANCH) ?? cfg.BRANCH;
  cfg.DIR = pick(LS_KEYS.DIR) ?? cfg.DIR;
  return cfg;
}

// Session: date-only default to today
function defaultSession(){ return todayYmd(); }
function fileNameFor(team, person, session){ return `${team} -- ${person} -- ${session}`.trim(); }
function filePathFor(team, person, session, cfg){ const fn = `${fileNameFor(team, person, session)}.txt`; const dir = cfg.DIR ? cfg.DIR.replace(/^\/+|\/+$/g, "") + "/" : ""; return dir + fn; }

function buildContentVars({ team, name, session, feeling, productivity, update, timestamp }){
  return [
    `TEAM="${team}"`,
    `NAME="${name}"`,
    `SESSION="${session}"`,
    `FEELING=${Number(feeling)}`,
    `PRODUCTIVITY=${Number(productivity)}`,
    `UPDATED_AT="${timestamp}"`,
    `UPDATE_B64="${toBase64(update ?? "")}"`,
  ].join("\n") + "\n";
}

function parseContentVars(text){
  const out = { team:"", name:"", session:"", feeling:null, productivity:null, update:"", updated_at:"", reactions: null };
  const lines = String(text).split(/\r?\n/);
  for (const raw of lines){
    const line = raw.trim(); if (!line || line.startsWith('#')) continue;
    const eq = line.indexOf('='); if (eq === -1) continue;
    const key = line.slice(0,eq).trim().toUpperCase();
    let val = line.slice(eq+1).trim();
    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) val = val.slice(1,-1);
    if (key === 'TEAM') out.team = val;
    else if (key === 'NAME') out.name = val;
    else if (key === 'SESSION') out.session = val;
    else if (key === 'FEELING') out.feeling = Number(val) || null;
    else if (key === 'PRODUCTIVITY') out.productivity = Number(val) || null;
    else if (key === 'UPDATED_AT') out.updated_at = val;
    else if (key === 'UPDATE_B64') out.update = fromBase64(val);
    else if (key === 'UPDATE') out.update = val;
    else if (key === 'REACTIONS_B64'){
      try { const obj = JSON.parse(fromBase64(val)||'{}'); if (obj && typeof obj === 'object') out.reactions = obj; } catch {}
    }
  }
  if (!out.reactions) out.reactions = { updated_at:null, by_target:{} };
  if (!out.reactions.by_target) out.reactions.by_target = {};
  return out;
}

function setLiveStatus({ label, color }){
  const dot = $('#liveDot'); const lbl = $('#liveLabel');
  if (dot) dot.setAttribute('fill', color || '#8e9bd6');
  if (lbl) lbl.textContent = label || 'Idle';
}
function setSaveStatus(msg, ok=true){ const el = $('#saveStatus'); if (el){ el.textContent = msg; el.style.color = ok ? '#b4bfed' : '#e74c3c'; } }
function recordApiError(err){ state.lastApiError = String(err?.message || err || ''); const el = $('#lastApiError'); if (el) el.textContent = state.lastApiError || 'None'; }
function updateLiveSinceTicker(){ const el = $('#liveSinceTicker'); if (!el) return; const ms = Date.now() - state.liveSinceMs; const s = Math.floor(ms/1000); const m = Math.floor(s/60); const rem = s%60; el.textContent = m ? `${m}m ${rem}s` : `${rem}s`; }

// ======= THEME & MODE =======
function setTheme(mode){ const m = (mode === 'light') ? 'light' : 'dark'; document.body.setAttribute('data-theme', m); const icon = $('#themeIcon'); const name = $('#themeName'); const btn = $('#themeToggle'); if (icon) icon.textContent = (m === 'dark') ? 'üåô' : '‚òÄÔ∏è'; if (name) name.textContent = (m === 'dark') ? 'Dark' : 'Light'; if (btn) btn.setAttribute('aria-pressed', String(m === 'dark')); localStorage.setItem(LS_KEYS.THEME, m); }
function initTheme(){ const saved = localStorage.getItem(LS_KEYS.THEME) || 'dark'; setTheme(saved); $('#themeToggle')?.addEventListener('click', ()=>{ const cur = document.body.getAttribute('data-theme'); setTheme(cur === 'dark' ? 'light' : 'dark'); }); }
function setMode(mode){ const m = (mode === 'facilitator') ? 'facilitator' : 'user'; $('#userSection').hidden = (m !== 'user'); $('#facilitatorSection').hidden = (m !== 'facilitator'); $('#modeUserBtn')?.classList.toggle('active', m === 'user'); $('#modeFacBtn')?.classList.toggle('active', m === 'facilitator'); localStorage.setItem(LS_KEYS.MODE, m); }
function initMode(){ const saved = localStorage.getItem(LS_KEYS.MODE) || 'user'; setMode(saved); $('#modeUserBtn')?.addEventListener('click', ()=> setMode('user')); $('#modeFacBtn')?.addEventListener('click', ()=> setMode('facilitator')); }

// ======= GAUGES: semi-arc with needle (blue‚Üígreen) =======
function setSemiGauge(kind, val){
  const arc = document.getElementById(`gauge${kind}Arc`);
  const needle = document.getElementById(`gauge${kind}Needle`);
  const label = document.getElementById(`gauge${kind}Val`);
  const container = document.getElementById(`gauge${kind}`);
  if (!arc || !needle || !label || !container) return;
  if (val === null || val === undefined || isNaN(val)){
    arc.style.strokeDasharray = `0 100`;
    needle.setAttribute('transform', 'rotate(-90 100 110)');
    label.textContent = '‚Äî';
    container.setAttribute('aria-valuenow', '0');
    return;
  }
  const clamped = Math.max(0, Math.min(10, Number(val)));
  const pct = Math.round((clamped/10)*100);
  arc.style.strokeDasharray = `${pct} 100`;
  const angle = -90 + (pct/100)*180; // -90¬∞ .. +90¬∞
  needle.setAttribute('transform', `rotate(${angle} 100 110)`);
  label.textContent = clamped.toFixed(1);
  container.setAttribute('aria-valuenow', String(clamped));
}

// ======= GITHUB API =======
function ghHeaders(token, etag){ const h = { 'Accept': 'application/vnd.github+json', 'Authorization': token ? `token ${token}` : undefined, 'Content-Type': 'application/json' }; if (etag) h['If-None-Match'] = etag; return h; }
async function ghFetch(path, { method='GET', body, etag }={}){ const url = `https://api.github.com${path}`; return fetch(url, { method, headers: ghHeaders(CONFIG_DEFAULTS.GITHUB_TOKEN, etag), body: body ? JSON.stringify(body) : undefined }); }
async function ghGetJsonWithEtag(path, cacheObj){ const prev = cacheObj[path] || {}; const res = await ghFetch(path, { etag: prev.etag }); if (res.status === 304) return { notModified:true, etag:prev.etag, data:prev.data }; if (!res.ok){ throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`); } const etag = res.headers.get('ETag'); const data = await res.json(); cacheObj[path] = { etag, data }; return { notModified:false, etag, data }; }
async function ghGetContentsMeta(cfg, filePath){ const enc = encodeURIComponent(filePath).replace(/%2F/g,'/'); const path = `/repos/${cfg.OWNER}/${cfg.REPO}/contents/${enc}?ref=${encodeURIComponent(cfg.BRANCH)}`; const res = await ghFetch(path); if (res.status === 404) return null; if (!res.ok){ const text = await res.text(); const e = new Error(`${res.status} ${res.statusText}: ${text}`); e.status = res.status; throw e; } const json = await res.json(); return { sha: json.sha, size: json.size, path: json.path };
}
async function writeFileOverwriteStrict(cfg, filePath, contentString, commitMessage){
  const enc = encodeURIComponent(filePath).replace(/%2F/g,'/');
  const put = async (sha)=>{ const body = { message: commitMessage, content: toBase64(contentString), branch: cfg.BRANCH, committer: { name:'Round Table App', email:'roundtable@example.com' } }; if (sha) body.sha = sha; const path = `/repos/${cfg.OWNER}/${cfg.REPO}/contents/${enc}`; const res = await ghFetch(path, { method:'PUT', body }); if (res.status === 200 || res.status === 201) return res.json(); const text = await res.text(); const err = new Error(`${res.status} ${res.statusText}: ${text}`); err.status = res.status; throw err; };
  let meta = await ghGetContentsMeta(cfg, filePath);
  try { return await put(meta?.sha); }
  catch (e){ const msg = String(e.message||''); if (e.status === 422 || /422/.test(msg) || /\"sha\" wasn't supplied|sha/i.test(msg)){ meta = await ghGetContentsMeta(cfg, filePath); if (meta?.sha) return await put(meta.sha); return await put(undefined); } if (e.status === 409){ meta = await ghGetContentsMeta(cfg, filePath); if (meta?.sha) return await put(meta.sha); } throw e; }
}
async function deleteFile(cfg, filePath, sha, message){ const enc = encodeURIComponent(filePath).replace(/%2F/g,'/'); const body = { message, sha, branch: cfg.BRANCH, committer: { name:'Round Table App', email:'roundtable@example.com' } }; const path = `/repos/${cfg.OWNER}/${cfg.REPO}/contents/${enc}`; const res = await ghFetch(path, { method:'DELETE', body }); if (!res.ok){ const t = await res.text(); const e = new Error(`${res.status} ${res.statusText}: ${t}`); e.status = res.status; throw e; } return res.json(); }

async function listDirectory(cfg){ const dir = cfg.DIR ? cfg.DIR.replace(/^\/+|\/+$/g, '') : ''; const encDir = dir ? `/${encodeURIComponent(dir).replace(/%2F/g,'/')}` : ''; const ref = encodeURIComponent(cfg.BRANCH); const path = `/repos/${cfg.OWNER}/${cfg.REPO}/contents${encDir}?ref=${ref}`; try { const { data } = await ghGetJsonWithEtag(path, state.cache.dir); const items = Array.isArray(data) ? data : []; return items.filter(x => x && x.type === 'file' && /\.txt$/i.test(x.name)); } catch { return []; } }
async function readFileContent(cfg, fileItem){ const encPath = (typeof fileItem === 'string') ? encodeURIComponent(fileItem).replace(/%2F/g,'/') : encodeURIComponent(fileItem.path).replace(/%2F/g,'/'); const ref = encodeURIComponent(cfg.BRANCH); const path = `/repos/${cfg.OWNER}/${cfg.REPO}/contents/${encPath}?ref=${ref}`; const prev = state.cache.files[path] || {}; const res = await ghFetch(path, { etag: prev.etag }); if (res.status === 304) return prev.text || ''; if (!res.ok){ throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`); } const etag = res.headers.get('ETag'); const json = await res.json(); let text = ''; if (json?.content && json.encoding === 'base64') text = fromBase64(json.content.replace(/\n/g,'')); state.cache.files[path] = { ...(state.cache.files[path]||{}), etag, text, sha: json.sha }; return text; }

// === Registry helpers ===
function safeJoin(...parts){ return parts.filter(Boolean).join('/').replace(/\\+/g,'/').replace(/\/\/+$/,''); }
function dirRoot(cfg){ return cfg.DIR ? cfg.DIR.replace(/^\/+|\/+$/g, '') : ''; }
function registryDir(cfg){ const root = dirRoot(cfg); return root ? `${root}/_teams` : `_teams`; }
async function listRegistry(cfg){ const reg = registryDir(cfg); const enc = encodeURIComponent(reg).replace(/%2F/g,'/'); const ref = encodeURIComponent(cfg.BRANCH); const path = `/repos/${cfg.OWNER}/${cfg.REPO}/contents/${enc}?ref=${ref}`; try { const { data } = await ghGetJsonWithEtag(path, state.cache.dir); const items = Array.isArray(data) ? data : []; return items.filter(x => x && x.type === 'file' && /\.json$/i.test(x.name)); } catch(e){ return []; } }
async function readJsonFile(cfg, path){ const enc = encodeURIComponent(path).replace(/%2F/g,'/'); const ref = encodeURIComponent(cfg.BRANCH); const api = `/repos/${cfg.OWNER}/${cfg.REPO}/contents/${enc}?ref=${ref}`; const prev = state.cache.files[api] || {}; const res = await ghFetch(api, { etag: prev.etag }); if (res.status === 304) { try { return JSON.parse(prev.text || '{}'); } catch { return {}; } } if (!res.ok){ const t = await res.text(); throw new Error(`${res.status} ${res.statusText}: ${t}`); } const etag = res.headers.get('ETag'); const json = await res.json(); let text=''; if (json?.content && json.encoding==='base64') text = fromBase64(json.content.replace(/\n/g,'')); state.cache.files[api] = { ...(state.cache.files[api]||{}), etag, text, sha: json.sha }; try { return JSON.parse(text||'{}'); } catch { return {}; } }

// ======= REACTIONS: aggregate & write to my own file =======
function emptyReactions(){ return {"üëç":0,"‚úÖ":0,"‚ù§Ô∏è":0}; }
function clone(obj){ return JSON.parse(JSON.stringify(obj||{})); }

async function aggregateReactions(parsedList){
  const totals = new Map();
  for (const u of parsedList){
    const byTarget = (u.reactions?.by_target) || {};
    for (const [base, flags] of Object.entries(byTarget)){
      const entry = totals.get(base) || emptyReactions();
      if (flags['üëç']) entry['üëç'] = (entry['üëç']||0) + 1;
      if (flags['‚úÖ']) entry['‚úÖ'] = (entry['‚úÖ']||0) + 1;
      if (flags['‚ù§Ô∏è']) entry['‚ù§Ô∏è'] = (entry['‚ù§Ô∏è']||0) + 1;
      totals.set(base, entry);
    }
  }
  return totals;
}

function myBaseForCurrent(){ const cfg = getConfig(); const name = (localStorage.getItem(LS_KEYS.NAME) || $('#nameInput')?.value || '').trim(); const session = ($('#sessionFilter')?.value || '').trim() || defaultSession(); if (!name) return null; return fileNameFor(cfg.TEAM_NAME, name, session); }

async function ensureMyFileExists(cfg){
  const name = (localStorage.getItem(LS_KEYS.NAME) || $('#nameInput')?.value || '').trim(); if (!name) throw new Error('Please enter your name first.');
  const session = ($('#sessionFilter')?.value || '').trim() || defaultSession();
  const path = filePathFor(cfg.TEAM_NAME, name, session, cfg);
  const meta = await ghGetContentsMeta(cfg, path);
  if (meta) return path;
  const payload = { team: cfg.TEAM_NAME, name, session, feeling: 0, productivity: 0, update: '', timestamp: nowIso() };
  const content = buildContentVars(payload);
  await writeFileOverwriteStrict(cfg, path, content, `Round Table: init file for ${name} (${cfg.TEAM_NAME} ‚Äî ${session})`);
  return path;
}

async function upsertMyReactions(cfg){
  const base = myBaseForCurrent(); if (!base) { alert('Enter your name to react.'); return; }
  const name = (localStorage.getItem(LS_KEYS.NAME) || $('#nameInput')?.value || '').trim();
  const session = ($('#sessionFilter')?.value || '').trim() || defaultSession();
  const path = await ensureMyFileExists(cfg);
  let text = '';
  try { text = await readFileContent(cfg, { path }); } catch { text = ''; }
  const lines = String(text||'').split(/\r?\n/);
  const idx = lines.findIndex(l => /^\s*REACTIONS_B64\s*=/.test(l));
  const payload = { updated_at: nowIso(), by_target: clone(state.myReactions.by_target) };
  const encoded = toBase64(JSON.stringify(payload));
  if (idx >= 0) lines[idx] = `REACTIONS_B64="${encoded}"`; else lines.push(`REACTIONS_B64="${encoded}"`);
  const newText = lines.join('\n');
  await writeFileOverwriteStrict(cfg, path, newText, `Round Table: reactions update for ${name} (${CONFIG_DEFAULTS.TEAM_NAME} ‚Äî ${session})`);
}

function scheduleWriteMyReactions(){
  const cfg = getConfig();
  if (state._rxDebounceTimer) clearTimeout(state._rxDebounceTimer);
  state._rxDebounceTimer = setTimeout(async ()=>{
    try { await upsertMyReactions(cfg); } catch(e){ recordApiError(e); }
    finally { state._rxDebounceTimer = null; setTimeout(refreshBoard, 400); }
  }, 500);
}

// ======= SPEAKER ORDER (per-session persisted) =======
function sessionKey(){ const cfg = getConfig(); const sess = ($('#sessionFilter')?.value || '').trim() || defaultSession(); return `${cfg.TEAM_NAME}::${sess}`; }
function loadSpeakerState(){ const raw = localStorage.getItem(LS_SPEAKER_PREFIX + sessionKey()); if (!raw) return { spoken: [], speakingNow: null, readyOrder: [] }; try { const s = JSON.parse(raw); return { spoken: s.spoken||[], speakingNow: s.speakingNow||null, readyOrder: s.readyOrder||[] }; } catch { return { spoken: [], speakingNow: null, readyOrder: [] }; } }
function saveSpeakerState(s){ state.speaker = s; localStorage.setItem(LS_SPEAKER_PREFIX + sessionKey(), JSON.stringify(s)); updateSpeakerCounts(); }
function clearSpeakerState(){ saveSpeakerState({ spoken: [], speakingNow: null, readyOrder: [] }); }
function updateSpeakerCounts(){ const s = state.speaker || loadSpeakerState(); const updates = state.currentUpdates; const names = new Set(updates.map(u=> u.name)); const spokenCt = (s.spoken||[]).filter(n=> names.has(n)).length; const remainingCt = Math.max(0, names.size - spokenCt); $('#speakerCounts').textContent = `Remaining: ${remainingCt} ‚Ä¢ Spoken: ${spokenCt}`; }

function shuffle(arr){ for (let i=arr.length-1; i>0; i--){ const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
function applySpeakerOrdering(updates){ const s = state.speaker || loadSpeakerState(); const spokenSet = new Set(s.spoken||[]); const byName = new Map(updates.map(u=> [u.name, u])); const ready = updates.filter(u=> !spokenSet.has(u.name)); const readyNames = new Set(ready.map(u=> u.name)); const savedOrder = (s.readyOrder||[]).filter(n=> readyNames.has(n)); const leftover = ready.filter(u=> !savedOrder.includes(u.name)).map(u=> u.name); const finalReadyNames = [...savedOrder, ...leftover]; const speaking = s.speakingNow && readyNames.has(s.speakingNow) ? s.speakingNow : null; const readyOrdered = (speaking ? [speaking] : []).concat(finalReadyNames.filter(n=> n!==speaking)).map(n=> byName.get(n)).filter(Boolean); const spokenOrdered = (s.spoken||[]).map(n=> byName.get(n)).filter(Boolean); return readyOrdered.concat(spokenOrdered); }
function nextSpeaker(){ const updates = state.currentUpdates; if (!updates.length) return; const s = state.speaker || loadSpeakerState(); const spokenSet = new Set(s.spoken||[]); const ready = updates.map(u=>u.name).filter(n=> !spokenSet.has(n)); if (!ready.length){ s.speakingNow = null; s.readyOrder = []; saveSpeakerState(s); renderUpdates(state.currentUpdates); return; } const order = shuffle(ready.slice()); s.readyOrder = order; s.speakingNow = order[0] || null; saveSpeakerState(s); renderUpdates(state.currentUpdates); }
function speakerFinished(){ const s = state.speaker || loadSpeakerState(); if (!s.speakingNow) return; if (!s.spoken.includes(s.speakingNow)) s.spoken.push(s.speakingNow); s.readyOrder = s.readyOrder.filter(n=> n!==s.speakingNow); s.speakingNow = null; saveSpeakerState(s); renderUpdates(state.currentUpdates); speakerClear(); }

// ======= TEAM DISCOVERY (GH-only for picker) & REGISTRY =======
function getStoredPass(team){ return localStorage.getItem(LS_PASS_PREFIX + team) || ''; }
function setStoredPass(team, pass){ localStorage.setItem(LS_PASS_PREFIX + team, pass || ''); }

async function discoverTeamsFromGitHub(cfg, dirItems){
  const regItems = await listRegistry(cfg); const regMap = new Map();
  for (const it of regItems){ try { const obj = await readJsonFile(cfg, it.path); if (obj && obj.team){ regMap.set(String(obj.team), { team: String(obj.team), passphrase: obj.passphrase || '', created_at: obj.created_at||'', created_by: obj.created_by||'' }); } } catch {}
  }
  state.teamRegistry = regMap;
  const legacy = new Set();
  for (const it of (dirItems||[])){
    const nm = (it.name||'').replace(/\.txt$/i,'');
    const team = nm.split(' -- ')[0]?.trim(); if (team) legacy.add(team);
  }
  // Prefer registry names + any legacy-only names
  const teams = [...new Set([ ...regMap.keys(), ...legacy ])];
  state.teamsFromGh = teams.sort((a,b)=> a.localeCompare(b));
  populateTeamSwitcher();
  populateDeleteTeamSelect();
}

function verifyPassForSelectedTeam(){
  const cfg = getConfig(); const team = cfg.TEAM_NAME; const reg = state.teamRegistry.get(team);
  const inp = $('#teamPassInput'); const msg = $('#passMsg');
  if (!reg || !reg.passphrase){ state.teamLocked = false; if (msg) msg.textContent = 'No pass needed'; inp?.classList.remove('error'); return true; }
  const entered = (inp?.value || getStoredPass(team) || '').trim();
  if (!entered || entered !== String(reg.passphrase)){
    state.teamLocked = true; if (msg) msg.textContent = 'Passphrase required or incorrect'; inp?.classList.add('error'); return false;
  }
  state.teamLocked = false; if (msg) msg.textContent = 'Verified ‚úì'; inp?.classList.remove('error'); if (inp && inp.value !== entered) inp.value = entered; setStoredPass(team, entered); return true;
}

function populateTeamSwitcher(){ const sel = $('#teamSwitcher'); if (!sel) return; const teams = state.teamsFromGh || []; const cur = getConfig().TEAM_NAME; sel.innerHTML = teams.map(t=> `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join(''); // choose existing if present, else first GH team
  let pick = teams.includes(cur) ? cur : (teams[0] || cur);
  sel.value = pick; if (pick !== cur){ localStorage.setItem(LS_KEYS.TEAM_NAME, pick); $('#teamNameDisplay').textContent = pick; }
}
function initTeamSwitcher(){ const inp = $('#teamPassInput'); const msg = $('#passMsg'); $('#teamSwitcher')?.addEventListener('change', ()=>{ const t = $('#teamSwitcher').value; localStorage.setItem(LS_KEYS.TEAM_NAME, t); $('#teamNameDisplay').textContent = t; const saved = getStoredPass(t); if (inp) inp.value = saved || ''; if (msg) msg.textContent = ''; clearSpeakerState(); refreshBoard(); }); if (inp){ inp.addEventListener('input', ()=>{ const t = getConfig().TEAM_NAME; setStoredPass(t, inp.value||''); const ok = verifyPassForSelectedTeam(); if (ok) refreshBoard(); }); } }

function initTeamCreate(){ const btn = $('#addTeamBtn'); const inp = $('#newTeamInput'); const pinp = $('#newTeamPassInput'); if (!btn || !inp) return; btn.addEventListener('click', async ()=>{ const t = (inp.value||'').trim(); const pass = (pinp?.value||'').trim(); if (!t) return; const cfg = getConfig(); const path = safeJoin(registryDir(cfg), `${t.replace(/[\\/]/g,'-')}.json`); const data = { team: t, passphrase: pass || '', created_at: nowIso(), created_by: (localStorage.getItem(LS_KEYS.NAME)||'facilitator') }; try { await writeFileOverwriteStrict(cfg, path, JSON.stringify(data, null, 2) + '\n', `Round Table: register team ${t}`); // refresh teams from GH only
      const dirItems = await listDirectory(cfg); await discoverTeamsFromGitHub(cfg, dirItems); localStorage.setItem(LS_KEYS.TEAM_NAME, t); setStoredPass(t, pass||''); $('#teamNameDisplay').textContent = t; $('#teamSwitcher').value = t; if ($('#teamPassInput')) $('#teamPassInput').value = pass || ''; if ($('#passMsg')) $('#passMsg').textContent = pass ? 'Verified ‚úì' : 'No pass needed'; inp.value=''; if (pinp) pinp.value=''; clearSpeakerState(); await refreshBoard(); } catch(e){ recordApiError(e); alert('Failed to create team. Check token permissions.'); } }); }

// ======= ADMIN BULK DELETE =======
function extractSessionsFromFiles(files, team){ const set = new Set(); for (const it of (files||[])){ const nm = (it.name||'').replace(/\.txt$/i,''); const parts = nm.split(' -- '); if (parts.length>=3 && parts[0].trim() === team) set.add(parts[2].trim()); } return [...set].sort(); }
function populateDeleteTeamSelect(){ const sel = $('#delTeamSelect'); if (!sel) return; const teams = state.teamsFromGh || []; sel.innerHTML = teams.map(t=> `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join(''); }
async function populateDeleteSessionSelect(){ const cfg = getConfig(); const files = await listDirectory(cfg); const sessions = extractSessionsFromFiles(files, cfg.TEAM_NAME); const sel = $('#delSessionSelect'); if (!sel) return; sel.innerHTML = sessions.map(s=> `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join(''); }

async function deleteBySession(session){ const cfg = getConfig(); if (!verifyPassForSelectedTeam()){ alert('Enter the correct passphrase for this team first.'); return; } if (!session){ alert('Pick a session to delete.'); return; } const ok = confirm(`Delete ALL files for session "${session}" in team "${cfg.TEAM_NAME}"? This cannot be undone.`); if (!ok) return; const files = await listDirectory(cfg); const targets = files.filter(it => (it.name||'').startsWith(cfg.TEAM_NAME + ' -- ') && (it.name||'').endsWith(` -- ${session}.txt`)); for (const it of targets){ try { const meta = await ghGetContentsMeta(cfg, it.path); if (meta?.sha) await deleteFile(cfg, it.path, meta.sha, `Round Table: delete session ${session} (${cfg.TEAM_NAME})`); } catch(e){ recordApiError(e); } } await refreshBoard(); await populateDeleteSessionSelect(); }

async function deleteByTeam(team){ const cfg = getConfig(); const reg = state.teamRegistry.get(team); // verify pass if available
  const stored = getStoredPass(team);
  if (reg && reg.passphrase && stored !== reg.passphrase){ alert(`Enter the passphrase for team "${team}" (switch to it in the header and provide the passphrase) before deleting.`); return; }
  const ok = confirm(`Delete ALL files for team "${team}" across ALL sessions? This cannot be undone.`); if (!ok) return; const files = await listDirectory(cfg); const targets = files.filter(it => (it.name||'').startsWith(team + ' -- ')); for (const it of targets){ try { const meta = await ghGetContentsMeta(cfg, it.path); if (meta?.sha) await deleteFile(cfg, it.path, meta.sha, `Round Table: delete team ${team}`); } catch(e){ recordApiError(e); } }
  // remove registry json
  const regPath = safeJoin(registryDir(cfg), `${team.replace(/[\\/]/g,'-')}.json`); try { const meta = await ghGetContentsMeta(cfg, regPath); if (meta?.sha) await deleteFile(cfg, regPath, meta.sha, `Round Table: remove team registry ${team}`); } catch(e) { /* ignore */ }
  // refresh picker
  const dirItems = await listDirectory(cfg); await discoverTeamsFromGitHub(cfg, dirItems); if ($('#teamSwitcher').value !== cfg.TEAM_NAME) { /* noop */ } await refreshBoard(); await populateDeleteSessionSelect(); }

function hookAdminDelete(){ $('#deleteSessionBtn')?.addEventListener('click', ()=>{ const s = $('#delSessionSelect')?.value || ''; deleteBySession(s); }); $('#deleteTeamBtn')?.addEventListener('click', ()=>{ const t = $('#delTeamSelect')?.value || ''; if (!t) return; deleteByTeam(t); }); }

// ======= RENDERING =======
function moodClass(n){ if (n >= 8) return 'ok'; if (n <= 3) return 'bad'; return 'warn'; }
function formatMultiline(text){ const lines = String(text||"").split(/\r?\n/); return lines.map(line => `<div>${linkify(escapeHtml(line || '')) || '&nbsp;'}</div>`).join(''); }
function cardHtml(u){ const feel = Number(u.feeling)||0; const prod = Number(u.productivity)||0; const moodEmoji = feel>=9?'ü§©':feel>=7?'üòÑ':feel>=5?'üôÇ':feel>=3?'üòê':'üòû'; const s = state.speaker || loadSpeakerState(); const spokenSet = new Set((s.spoken||[])); const isSpeaking = s.speakingNow && s.speakingNow === u.name; const isSpoken = spokenSet.has(u.name); const badges = [ isSpeaking ? '<span class="tag live">Speaking now</span>' : '', isSpoken ? '<span class="tag spoken">Spoken</span>' : '' ].filter(Boolean).join(' '); const totals = state.reactionTotals.get(u.__base) || emptyReactions(); const mine = (state.myReactions.by_target || {})[u.__base] || {}; return `
    <div class="update-card" data-base="${escapeHtml(u.__base)}" data-name="${escapeHtml(u.name)}">
      <div class="update-head">
        <div class="who">${escapeHtml(u.name || 'Unknown')} ${badges ? badges : ''} <span class="muted">‚Ä¢ ${escapeHtml(u.session||'')}</span></div>
        <div class="when">${escapeHtml(fmtLocal(u.updated_at || ''))}</div>
      </div>
      <div class="muted" style="margin-bottom:6px;">
        ${moodEmoji} Mood: <b class="${moodClass(feel)}">${feel || '-'}</b>
        &nbsp;‚Ä¢&nbsp;
        Productivity: <b class="${moodClass(prod)}">${prod || '-'}</b>
      </div>
      <div>${formatMultiline(u.update)}</div>
      <div class="reactions">
        <button class="react-btn ${mine['üëç']?'active':''}" data-react="üëç" type="button">üëç <span class="cnt" data-react-cnt> ${totals['üëç']||0}</span></button>
        <button class="react-btn ${mine['‚úÖ']?'active':''}" data-react="‚úÖ" type="button">‚úÖ <span class="cnt" data-react-cnt> ${totals['‚úÖ']||0}</span></button>
        <button class="react-btn ${mine['‚ù§Ô∏è']?'active':''}" data-react="‚ù§Ô∏è" type="button">‚ù§Ô∏è <span class="cnt" data-react-cnt> ${totals['‚ù§Ô∏è']||0}</span></button>
      </div>
    </div>`; }

function renderTeamSnapshot(updates){ const avg = (arr)=> arr.length ? (arr.reduce((a,b)=>a+b,0) / arr.length) : 0; const feelings = updates.map(u=> Number(u.feeling)).filter(n=> !isNaN(n)); const prods = updates.map(u=> Number(u.productivity)).filter(n=> !isNaN(n)); const avgFeeling = feelings.length ? avg(feelings) : null; const avgProd = prods.length ? avg(prods) : null; $('#updatesCount').textContent = String(updates.length); setSemiGauge('Feeling', avgFeeling); setSemiGauge('Productivity', avgProd); updateSpeakerCounts(); }

function applySpokenFilter(list){ const f = state.sfilter || 'all'; if (f === 'all') return list; const s = state.speaker || loadSpeakerState(); const spoken = new Set((s.spoken||[])); if (f === 'ready') return list.filter(u=> !spoken.has(u.name)); if (f === 'spoken') return list.filter(u=> spoken.has(u.name)); return list; }
function matchFilter(u, [sessionNeedle, textNeedle]){ if (sessionNeedle){ const sn = sessionNeedle.toLowerCase(); if (!(u.session||'').toLowerCase().includes(sn)) return false; } if (!textNeedle) return true; const n = textNeedle.toLowerCase(); return ((u.name||'').toLowerCase().includes(n) || (u.team||'').toLowerCase().includes(n) || (u.update||'').toLowerCase().includes(n)); }
function renderUpdates(updates){ const grid = $('#updatesGrid'); if (!grid) return; const sessionVal = $('#sessionFilter').value.trim(); const filterVal = $('#filterInput').value.trim(); const filtered = applySpokenFilter(updates.filter(u=> matchFilter(u, [sessionVal, filterVal]))); const s = state.speaker || loadSpeakerState(); const hasSpeakerState = (s.speakingNow || (s.spoken||[]).length || (s.readyOrder||[]).length); const list = hasSpeakerState ? applySpeakerOrdering(filtered) : filtered.slice(); grid.innerHTML = list.map(cardHtml).join(''); }
function renderMyLast(u){ const el = $('#myLastCard'); if (!el) return; if (!u) { el.textContent = 'No submission yet.'; return; } el.innerHTML = cardHtml(u); }

// ======= SAVE / LOAD =======
async function saveMyUpdate(evt){ evt?.preventDefault?.(); const cfg = getConfig(); if (!CONFIG_DEFAULTS.GITHUB_TOKEN || CONFIG_DEFAULTS.GITHUB_TOKEN.includes('PASTE_GITHUB_TOKEN_HERE')){ setSaveStatus('Missing GitHub token in roundtable.js ‚Äî please set CONFIG_DEFAULTS.GITHUB_TOKEN.', false); return; } const name = $('#nameInput').value.trim(); const session = ($('#sessionInput').value.trim() || defaultSession()); const feeling = Number($('#feelingInput').value); const productivity = Number($('#productivityInput').value); const updateText = $('#updateInput').value.trim(); if (!name){ setSaveStatus('Please enter your name before saving.', false); $('#nameInput').focus(); return; } localStorage.setItem(LS_KEYS.NAME, name); localStorage.setItem(LS_KEYS.SESSION, session); $('#sessionFilter').value = session; const payload = { team:getConfig().TEAM_NAME, name, session, feeling, productivity, update: updateText, timestamp: nowIso() }; const filePath = filePathFor(getConfig().TEAM_NAME, name, session, cfg); const content = buildContentVars(payload); const commitMessage = `Round Table: update for ${name} (${cfg.TEAM_NAME} ‚Äî ${session})`; try { setLiveStatus({ label:'Saving‚Ä¶', color:'#6a8bff' }); setSaveStatus('Saving‚Ä¶'); await writeFileOverwriteStrict(cfg, filePath, content, commitMessage); setSaveStatus('Saved!'); setLiveStatus({ label:'Synced', color:'#2ecc71' }); await refreshBoard(); renderMyLast({ ...payload, updated_at: payload.timestamp }); } catch (e){ console.error(e); recordApiError(e); setSaveStatus(`Save failed: ${e.message}`, false); setLiveStatus({ label:'Error', color:'#e74c3c' }); } }

async function refreshBoard(){ if (state.isSyncing) return; const cfg = getConfig(); state.isSyncing = true; setLiveStatus({ label: state.backoffMs ? `Syncing (backoff ${Math.round(state.backoffMs/1000)}s)‚Ä¶` : 'Syncing‚Ä¶', color:'#6a8bff' }); $('#updatesGrid').setAttribute('aria-busy','true'); try { const list = await listDirectory(cfg); await discoverTeamsFromGitHub(cfg, list); const tOk = verifyPassForSelectedTeam(); if (!tOk){ state.currentUpdates = []; state.reactionTotals = new Map(); $('#updatesCount').textContent = '0'; setSemiGauge('Feeling', null); setSemiGauge('Productivity', null); $('#updatesGrid').innerHTML = `<div class="update-card">This team is passphrase‚Äëprotected. Enter the passphrase to view updates.</div>`; $('#lastRefresh').textContent = new Date().toLocaleTimeString(); setLiveStatus({ label:'Locked', color:'#e6b34b' }); state.backoffMs = 0; await populateDeleteSessionSelect(); return; } const teamNeedle = String(cfg.TEAM_NAME).toLowerCase(); const sessionNeedle = $('#sessionFilter').value.trim().toLowerCase(); const teamFiles = list.filter(it => (it.name||'').toLowerCase().startsWith(teamNeedle + ' -- ')); const sessionFiles = sessionNeedle ? teamFiles.filter(it => (it.name||'').toLowerCase().endsWith(` -- ${sessionNeedle}.txt`)) : teamFiles; const parsed = []; for (const it of sessionFiles){ const text = await readFileContent(cfg, it); const meta = parseContentVars(text); meta.__txtPath = it.path; meta.__base = (it.name||'').replace(/\.txt$/i,''); parsed.push(meta); } state.currentUpdates = parsed; state.reactionTotals = await aggregateReactions(parsed); const myBase = myBaseForCurrent(); const me = parsed.find(u => u.__base === myBase); state.myReactions = me?.reactions || { updated_at:null, by_target:{} }; renderTeamSnapshot(parsed); renderUpdates(parsed); $('#lastRefresh').textContent = new Date().toLocaleTimeString(); setLiveStatus({ label:'Updated', color:'#2ecc71' }); state.backoffMs = 0; await populateDeleteSessionSelect(); } catch (e){ console.error(e); recordApiError(e); setLiveStatus({ label:'Sync error', color:'#e74c3c' }); const msg = String(e.message||''); if (/^403\b|^429\b|rate limit/i.test(msg)) state.backoffMs = state.backoffMs ? Math.min(state.backoffMs*2, 60000) : 5000; } finally { state.isSyncing = false; $('#updatesGrid').setAttribute('aria-busy','false'); scheduleNextPoll(); } }

function scheduleNextPoll(){ const cfg = getConfig(); const base = Math.max(2000, Number(cfg.POLL_INTERVAL_MS)||10000); const wait = base + (state.backoffMs||0); if (state.nextPollTimeout) clearTimeout(state.nextPollTimeout); state.nextPollTimeout = setTimeout(refreshBoard, wait); }

// ======= CSV/JSON EXPORT =======
function buildCsv(rows){ const esc = (v)=> '"'+ String(v ?? "").replace(/"/g,'""') +'"'; const head = ["Team","Session","Name","Feeling","Productivity","UpdatedAt","Update"]; const body = rows.map(r=> [r.team, r.session, r.name, r.feeling, r.productivity, r.updated_at, r.update].map(esc).join(',')); return head.map(esc).join(',') + "\n" + body.join("\n"); }
function downloadBlob(filename, mime, text){ const blob = new Blob([text], { type:mime }); const url = URL.createObjectURL(blob); const a = $('#downloadAnchor') || Object.assign(document.createElement('a'), { style:'display:none' }); if (!a.parentNode) document.body.appendChild(a); a.href = url; a.download = filename; a.click(); setTimeout(()=> URL.revokeObjectURL(url), 1000); }
function exportCsvCurrentSession(){ const sessionVal = $('#sessionFilter').value.trim(); const rows = state.currentUpdates.filter(u => !sessionVal || (u.session||'').includes(sessionVal)); const csv = buildCsv(rows); const cfg = getConfig(); downloadBlob(`${cfg.TEAM_NAME}-${sessionVal||'all'}.csv`, 'text/csv', csv); }
function exportJsonCurrentSession(){ const sessionVal = $('#sessionFilter').value.trim(); const rows = state.currentUpdates.filter(u => !sessionVal || (u.session||'').includes(sessionVal)); const json = JSON.stringify(rows, null, 2); const cfg = getConfig(); downloadBlob(`${cfg.TEAM_NAME}-${sessionVal||'all'}.json`, 'application/json', json); }

// ======= DIAGNOSTICS =======
async function runDiagnostics(){ const cfg = getConfig(); const set = (sel, txt)=>{ const el=$(sel); if (el) el.textContent = txt; }; const setStatus = (t)=>{ const el=$('#diagStatus'); if (el) el.textContent = t; }; try { setStatus('Checking token‚Ä¶'); const resUser = await ghFetch('/user'); const scopes = resUser.headers.get('X-OAuth-Scopes') || resUser.headers.get('x-oauth-scopes') || '(fine-grained or hidden)'; set('#diagTokenScope', scopes || 'Unknown'); setStatus('Checking branch‚Ä¶'); const resBranch = await ghFetch(`/repos/${cfg.OWNER}/${cfg.REPO}/branches/${encodeURIComponent(cfg.BRANCH)}`); if (!resBranch.ok) throw new Error(`Branch check failed: ${resBranch.status}`); setStatus('Checking directory‚Ä¶'); const dir = cfg.DIR ? `/${encodeURIComponent(cfg.DIR).replace(/%2F/g,'/')}` : ''; const resDir = await ghFetch(`/repos/${cfg.OWNER}/${cfg.REPO}/contents${dir}?ref=${encodeURIComponent(cfg.BRANCH)}`); if (resDir.status === 404) set('#diagBranchDir', `Branch ${cfg.BRANCH} OK ‚Ä¢ Directory '${cfg.DIR || '/'}' not found (will be created on first save)`); else if (resDir.ok) set('#diagBranchDir', `Branch ${cfg.BRANCH} OK ‚Ä¢ Directory '${cfg.DIR || '/'}' OK`); else set('#diagBranchDir', `Directory check error: ${resDir.status}`); setStatus('Done'); } catch (e){ recordApiError(e); setStatus('Error ‚Äî see Last API error'); } }

// ======= FACILITATOR TIMERS (with overtime flash) =======
let meetingTimerId = null, meetingEndAt = null, meetingRemainingMs = null;
let speakerTimerId = null, speakerEndAt = null, speakerRemainingMs = null;
function fmtMeeting(ms){ const totalS = Math.max(0, Math.round(ms/1000)); const m = Math.floor(totalS/60); const s = totalS % 60; return `${m}:${pad(s)}`; }
function fmtSpeaker(ms){ const totalS = Math.max(0, Math.round(ms/1000)); const m = Math.floor(totalS/60); const s = totalS % 60; return `${pad(m)}:${pad(s)}`; }
function meetingUpdate(){ const disp = $('#meetingDisplay'); if (!disp) return; const ms = Math.max(0, (meetingEndAt||0) - Date.now()); meetingRemainingMs = ms; disp.textContent = fmtMeeting(ms); if (ms <= 0){ clearInterval(meetingTimerId); meetingTimerId = null; } }
function speakerUpdate(){ const disp = $('#speakerDisplay'); if (!disp) return; const ms = Math.max(0, (speakerEndAt||0) - Date.now()); speakerRemainingMs = ms; disp.textContent = fmtSpeaker(ms); if (ms <= 0){ disp.classList.add('overtime'); clearInterval(speakerTimerId); speakerTimerId = null; } }
function meetingStart(){ const mins = Math.max(1, Number($('#meetingMinutesInput').value) || 45); const startMs = (meetingRemainingMs != null ? meetingRemainingMs : mins*60000); meetingEndAt = Date.now() + startMs; clearInterval(meetingTimerId); meetingTimerId = setInterval(meetingUpdate, 250); meetingUpdate(); }
function meetingStop(){ if (meetingTimerId){ clearInterval(meetingTimerId); meetingTimerId = null; } }
function meetingReset(){ meetingStop(); meetingRemainingMs = null; const mins = Math.max(1, Number($('#meetingMinutesInput').value) || 45); $('#meetingDisplay').textContent = fmtMeeting(mins*60000); }
function speakerStart(){ const disp = $('#speakerDisplay'); disp.classList.remove('overtime'); const mins = Math.max(0.1, Number($('#speakerMinutesInput').value) || 2); const startMs = (speakerRemainingMs != null ? speakerRemainingMs : mins*60000); speakerEndAt = Date.now() + startMs; clearInterval(speakerTimerId); speakerTimerId = setInterval(speakerUpdate, 250); speakerUpdate(); }
function speakerStop(){ if (speakerTimerId){ clearInterval(speakerTimerId); speakerTimerId = null; } }
function speakerClear(){ speakerStop(); const disp = $('#speakerDisplay'); disp.classList.remove('overtime'); speakerRemainingMs = null; const mins = Math.max(0.1, Number($('#speakerMinutesInput').value) || 2); disp.textContent = fmtSpeaker(mins*60000); }
function hookFacilitator(){ $('#meetingStart')?.addEventListener('click', meetingStart); $('#meetingStop')?.addEventListener('click', meetingStop); $('#meetingReset')?.addEventListener('click', meetingReset); $('#meetingMinutesInput')?.addEventListener('change', meetingReset); $('#speakerStart')?.addEventListener('click', speakerStart); $('#speakerStop')?.addEventListener('click', speakerStop); $('#speakerClear')?.addEventListener('click', speakerClear); $('#speakerMinutesInput')?.addEventListener('change', ()=>{ if (!speakerTimerId) speakerClear(); }); $('#nextSpeakerBtn')?.addEventListener('click', nextSpeaker); $('#speakerFinishedBtn')?.addEventListener('click', speakerFinished); $('#clearSpokenBtn')?.addEventListener('click', ()=>{ clearSpeakerState(); renderUpdates(state.currentUpdates); }); meetingReset(); speakerClear(); hookAdminDelete(); }

// ======= UI HOOKS =======
function applySettingsToUi(cfg){ $('#teamNameDisplay').textContent = cfg.TEAM_NAME || 'Team'; const savedName = localStorage.getItem(LS_KEYS.NAME); if (savedName) $('#nameInput').value = savedName; const today = todayYmd(); $('#sessionInput').value = today; $('#sessionFilter').value = today; const pass = getStoredPass(cfg.TEAM_NAME); if ($('#teamPassInput')) $('#teamPassInput').value = pass || ''; if ($('#passMsg')) $('#passMsg').textContent = ''; }
function hookInputs(){ const feel = $('#feelingInput'); const feelB = $('#feelingBubble'); feel?.addEventListener('input', ()=>{ feelB.textContent = feel.value; setBubbleHue(feelB, feel.value); }); feelB.textContent = feel?.value || '5'; setBubbleHue(feelB, feel?.value || 5); const prod = $('#productivityInput'); const prodB = $('#productivityBubble'); prod?.addEventListener('input', ()=>{ prodB.textContent = prod.value; setBubbleHue(prodB, prod.value); }); prodB.textContent = prod?.value || '5'; setBubbleHue(prodB, prod?.value || 5); document.querySelectorAll('.chip[data-feel]').forEach(chip=> chip.addEventListener('click', ()=>{ const v = chip.getAttribute('data-feel'); feel.value = v; feel.dispatchEvent(new Event('input')); document.querySelectorAll('.chip[data-feel]').forEach(c=>c.classList.remove('active')); chip.classList.add('active'); })); $('#updateForm')?.addEventListener('submit', saveMyUpdate); $('#manualRefreshBtn')?.addEventListener('click', refreshBoard); $('#clearBtn')?.addEventListener('click', ()=>{ $('#updateInput').value=''; }); $('#filterInput')?.addEventListener('input', ()=> renderUpdates(state.currentUpdates)); $('#sessionFilter')?.addEventListener('input', ()=> { state.speaker = loadSpeakerState(); updateSpeakerCounts(); renderUpdates(state.currentUpdates); }); $('#sortBySelect')?.addEventListener('change', ()=> renderUpdates(state.currentUpdates)); $('#exportCsvBtn')?.addEventListener('click', exportCsvCurrentSession); $('#exportJsonBtn')?.addEventListener('click', exportJsonCurrentSession); $('#runDiagnosticsBtn')?.addEventListener('click', runDiagnostics); const seg = $('#spokenSeg'); if (seg){ seg.addEventListener('click', (e)=>{ const btn = e.target.closest('.seg.spk'); if (!btn) return; seg.querySelectorAll('.seg').forEach(b=> b.classList.remove('active')); btn.classList.add('active'); state.sfilter = btn.getAttribute('data-sfilter') || 'all'; localStorage.setItem(LS_KEYS.SPOKEN_FILTER, state.sfilter); renderUpdates(state.currentUpdates); }); const savedF = localStorage.getItem(LS_KEYS.SPOKEN_FILTER) || 'all'; state.sfilter = savedF; seg.querySelectorAll('.seg').forEach(b=> b.classList.remove('active')); const activ = seg.querySelector(`.seg[data-sfilter="${savedF}"]`) || $('#spkAllBtn'); activ?.classList.add('active'); }
  // Reaction click (delegate)
  $('#updatesGrid')?.addEventListener('click', async (e)=>{ const btn = e.target.closest('.react-btn'); if (!btn) return; const card = e.target.closest('.update-card'); if (!card) return; const base = card.getAttribute('data-base'); const emoji = btn.getAttribute('data-react'); const cfg = getConfig(); const myMap = state.myReactions.by_target || (state.myReactions.by_target = {}); const cur = myMap[base] || {}; const had = !!cur[emoji]; cur[emoji] = !had; myMap[base] = cur; state.myReactions.updated_at = nowIso(); const totals = state.reactionTotals.get(base) || emptyReactions(); totals[emoji] = Math.max(0, (totals[emoji]||0) + (had ? -1 : +1)); state.reactionTotals.set(base, totals); const cntSpan = btn.querySelector('[data-react-cnt]'); if (cntSpan) cntSpan.textContent = ` ${totals[emoji]||0}`; btn.classList.toggle('active', !had); scheduleWriteMyReactions(); }); }

function setBubbleHue(el, val){ const v = Math.max(1, Math.min(10, Number(val)||5)); const t = (v-1)/9; const hue = Math.round(220 + (140-220)*t); el.style.background = `hsl(${hue} 70% 20% / .25)`; el.style.borderColor = `hsl(${hue} 70% 40% / .35)`; }

// ======= INIT =======
function startLiveSince(){ setInterval(updateLiveSinceTicker, 1000); updateLiveSinceTicker(); }
async function init(){ initTheme(); initMode(); applySettingsToUi(getConfig()); initTeamSwitcher(); initTeamCreate(); state.speaker = loadSpeakerState(); hookInputs(); hookFacilitator(); startLiveSince(); // Initial GH-only team population occurs inside refreshBoard() via discoverTeamsFromGitHub
  await refreshBoard(); }

document.addEventListener('DOMContentLoaded', init);


    </script>


</body>
</html>


